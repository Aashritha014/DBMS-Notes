{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DBMS Notes","text":"<p>Welcome to my Database Management Systems (DBMS) notes! This site is organized into 5 units with detailed topics and explanations. Explore each unit using the colored cards below.</p>"},{"location":"#units","title":"\ud83d\udcd1 Units","text":"Unit 1: Introduction to DBMS <p>Overview:  Data vs Information | Database and DBMS | Types of Databases | Applications | Characteristics &amp; Features | DB: Tasks in DBMS | Advantages OF DBMS | Disadvantages of DBMS | History of Database System | File System Approcah | View of Data | Data Abstraction | Data Independance | EF Codd Rules | DB: Languages | DB: Design Process | DBS: Architecture | DB: Architecture | \u27a1 Full Unit 1 Notes </p> Unit 2: Relational Model <p>Overview: Understand relations, keys, constraints, and ER diagrams. \u27a1 Go to Unit 2</p> Unit 3: SQL &amp; Query Processing <p>Overview: Dive into SQL commands, joins, and query optimization. \u27a1 Go to Unit 3</p> Unit 4: Transaction Management <p>Overview: Learn about transactions, ACID properties, and concurrency. \u27a1 Go to Unit 4</p> Unit 5: Database System Architectures <p>Overview: Explore DBMS architectures, distributed databases, and storage. \u27a1 Go to Unit 5</p> <p>Made with \ud83e\udde1 by Aashritha Reddy GitHub: Aashritha014 | Blog</p>"},{"location":"unit1/","title":"Unit 1: Introduction to DBMS","text":""},{"location":"unit1/#data-vs-information","title":"Data vs Information","text":"Aspect Data Information Definition Raw, unprocessed facts and figures. Processed, organized, and meaningful data. Nature Unstructured or structured values. Structured and contextually relevant. Example A list of numbers: 23, 45, 67, 89 (without context). The average test score of students is 56%. Processing Requires processing to be useful. Already processed and meaningful. Storage in DBMS Stored as tables, records, and fields. Retrieved as reports, summaries, or insights. Usage Used as input for processing. Used for decision-making."},{"location":"unit1/#database-and-dbms","title":"Database and DBMS","text":"<ul> <li>A database is an organized collection of structured information, or data, typically stored electronically in a computer system</li> <li>It is the collection of interrelated data that is organised in a way that data can be easily accessed, managed and updated.</li> <li>It is designed to handle large amounts of structured information and supports various operations like querying, updating, and deleting data.</li> <li>Databases are managed using\u00a0Database Management Systems (DBMS), which provide an interface to interact with the data.</li> <li>The DBMS also handles tasks like backup, recovery, and query optimization to maintain the database\u2019s performance.</li> <li>Examples of databases include MySQL, PostgreSQL, MongoDB, and Oracle Database.</li> <li>Databases can store data in the form of tables depending upon the type of database.</li> </ul>"},{"location":"unit1/#types-of-databases","title":"Types of Databases","text":"<ul> <li>Relational Databases (RDBMS)\u00a0\u2013 Use tables with rows and columns (e.g: MySQL, PostgreSQL).</li> <li>NoSQL Databases\u00a0\u2013 Store data in flexible formats like key-value pairs, documents, or graphs (e.g: MongoDB, Redis).</li> <li>Cloud Databases\u00a0\u2013 Hosted on cloud platforms for scalability (e.g: Google BigQuery, Amazon RDS).</li> <li>Distributed Databases\u00a0\u2013 Spread across multiple locations for high availability (e.g: Apache Cassandra).</li> </ul>"},{"location":"unit1/#applications","title":"Applications","text":"<ol> <li>Railway and Airline Reservation Systems:<ul> <li>Manages ticket bookings, schedules, and delays.</li> </ul> </li> <li>Library Management System:<ul> <li>Tracks books, issue dates, authors, and availability.</li> </ul> </li> <li>Banking:<ul> <li>Handles transactions, account details, and fund transfers.</li> </ul> </li> <li>Educational Institutions:<ul> <li>Stores student records, results, and course details.</li> </ul> </li> <li>Credit Card Transactions:<ul> <li>Secures transaction history and cardholder data.</li> </ul> </li> <li>Social Media Platforms:<ul> <li>Stores user data, posts, and interactions.</li> </ul> </li> <li>Finance and Business:<ul> <li>Manages sales, investments, and financial statements.</li> </ul> </li> <li>Military:<ul> <li>Maintains highly secure defense-related data.</li> </ul> </li> <li>Online Shopping:<ul> <li>Stores product inventory, customer orders, and payments.</li> </ul> </li> <li>Human Resource Management:<ul> <li>Keeps track of employee details, salaries, and taxes.</li> </ul> </li> <li>Manufacturing and Supply Chain:<ul> <li>Manages production, inventory, and sales.</li> </ul> </li> </ol>"},{"location":"unit1/#characteristics-features","title":"Characteristics &amp; Features","text":"<ol> <li>Data Stored in Tables<ul> <li>Data is stored in tables with relationships between them, making it structured and meaningful.</li> </ul> </li> <li>Data Abstraction:<ul> <li>Hides complexity and provides a simplified view of data storage.</li> </ul> </li> <li>Data Independence<ul> <li>Schema changes do not affect applications accessing the data.</li> </ul> </li> <li>Reduced Redundancy<ul> <li>Uses\u00a0Normalization\u00a0to minimize data repetition, reducing storage costs and improving consistency.</li> </ul> </li> <li>Efficient Data Access<ul> <li>Database systems structure data using\u00a0predefined schemas and data models, allowing efficient\u00a0storage and retrieval.</li> <li>They\u00a0eliminate redundancy and anomalies\u00a0by enforcing constraints and rules, maintaining\u00a0data accuracy and reliability.</li> </ul> </li> <li>Support for Multiple Users and Concurrent Access <ul> <li>Multiple users\u00a0can\u00a0access and manipulate\u00a0data\u00a0simultaneously\u00a0while ensuring\u00a0data consistency\u00a0across applications.</li> <li>Supports\u00a0collaborative data sharing\u00a0without conflicts, making it easier for teams to work on shared datasets.</li> </ul> </li> <li>Query Language<ul> <li>Provides a simple query language like\u00a0SQL\u00a0for data retrieval, insertion, deletion, and updates.</li> </ul> </li> <li>Security <ul> <li>Database systems implement\u00a0strong security measures\u00a0to prevent\u00a0unauthorized access\u00a0and\u00a0protect sensitive data.</li> <li>Security mechanisms like\u00a0authentication, authorization, and encryption\u00a0help preserve\u00a0data confidentiality and privacy.</li> </ul> </li> <li>Data Integrity and Consistency <ul> <li>Ensures correctness and completeness using constraints like\u00a0primary keys, foreign keys, and unique constraints.</li> <li>Enforces\u00a0ACID (Atomicity, Consistency, Isolation, Durability)\u00a0properties to ensure\u00a0reliable transactions.</li> <li>Prevents inconsistencies by maintaining\u00a0referential integrity\u00a0and enforcing\u00a0business rules\u00a0through constraints.</li> </ul> </li> <li>Backup and Recovery <ul> <li>Provides\u00a0automatic data backups\u00a0and\u00a0transaction management\u00a0to safeguard data from\u00a0system crashes or failures.</li> <li>Ensures\u00a0data durability, meaning no data is lost even if a system failure occurs.</li> </ul> </li> <li>Data Sharing <ul> <li>Enables authorized users to access shared data as needed.</li> </ul> </li> <li>Scalability\u00a0&amp; Performance Optimization<ul> <li>Database systems are designed to handle\u00a0large volumes of data\u00a0efficiently, supporting\u00a0business growth and expansion.</li> <li>Indexing, query optimization, and caching improve\u00a0performance and speed\u00a0in retrieving information</li> </ul> </li> </ol>"},{"location":"unit1/#db-tasks-in-dbms","title":"DB: Tasks in DBMS","text":"<ul> <li>Data Definition\u00a0\u2013 Defines database structures, including tables, fields, and relationships using\u00a0Data Definition Language (DDL).</li> <li>Data Storage Management\u00a0\u2013 Efficiently stores and organizes data in tables.</li> <li>Data Manipulation\u00a0\u2013 Supports inserting, updating, deleting, and retrieving data using\u00a0Data Manipulation Language (DML).</li> <li>Data Retrieval\u00a0\u2013 Uses query languages like\u00a0SQL\u00a0to extract relevant information.</li> <li>Query Processing &amp; Optimization\u00a0\u2013 Executes and optimizes queries for faster data retrieval.</li> <li>Transaction Management\u00a0\u2013 Ensures\u00a0ACID properties\u00a0(Atomicity, Consistency, Isolation, Durability) for reliable transactions.</li> <li>Concurrency Control\u00a0\u2013 Manages multiple users accessing the database simultaneously without conflicts.</li> <li>Data Security &amp; Access Control\u00a0\u2013 Prevents unauthorized access through authentication, user permissions, and encryption.</li> <li>Data Integrity Enforcement\u00a0\u2013 Ensures correctness using constraints like\u00a0primary keys, foreign keys, and unique constraints.</li> <li>Backup and Recovery\u00a0\u2013 Provides data recovery options in case of system failures or corruption.</li> <li>Data Redundancy Control\u00a0\u2013 Minimizes duplicate data through\u00a0Normalization\u00a0techniques.</li> <li>Indexing &amp; Performance Tuning\u00a0\u2013 Uses indexing and optimization techniques for faster data retrieval.</li> <li>Logging &amp; Monitoring\u00a0\u2013 Keeps logs of database activities and monitors performance for maintenance.</li> <li>Improved Data Sharing\u00a0\u2013 Enables multiple users to access and share data efficiently while maintaining security and consistency.</li> </ul>"},{"location":"unit1/#advantages-of-dbms","title":"Advantages OF DBMS","text":"<ol> <li>Data Redundancy Control\u00a0\u2013 Minimizes data duplication using\u00a0Normalization, ensuring efficient storage.</li> <li>Data Consistency\u00a0\u2013 Maintains data accuracy and prevents inconsistencies across multiple users.</li> <li>Improved Data Security\u00a0\u2013 Uses authentication, access control, and encryption to protect data.</li> <li>Data Integrity\u00a0\u2013 Enforces constraints like\u00a0primary keys and foreign keys\u00a0to maintain correctness.</li> <li>Concurrent Access &amp; Multi-User Support\u00a0\u2013 Allows multiple users to access and modify data simultaneously while ensuring\u00a0ACID properties.</li> <li>Backup &amp; Recovery\u00a0\u2013 Provides mechanisms to recover data in case of system failures or crashes.</li> <li>Efficient Data Retrieval\u00a0\u2013 Uses indexing, query optimization, and caching for faster data access.</li> <li>Standardized Query Language\u00a0\u2013 Supports\u00a0SQL\u00a0for easy data manipulation and retrieval.</li> <li>Scalability\u00a0\u2013 Can handle growing amounts of data efficiently.</li> <li>Data Sharing &amp; Centralized Management\u00a0\u2013 Enables multiple users to share data while maintaining control.</li> </ol>"},{"location":"unit1/#disadvantages-of-dbms","title":"Disadvantages of DBMS","text":"<ol> <li>High Initial Cost\u00a0\u2013 Requires investment in hardware, software, and skilled personnel.</li> <li>Complexity\u00a0\u2013 Requires expertise to design, manage, and maintain databases efficiently.</li> <li>Performance Overhead\u00a0\u2013 Extra processing for security, integrity checks, and concurrency control can slow down operations.</li> <li>Failure Impact\u00a0\u2013 A database crash or corruption can lead to significant data loss if backups are not properly managed.</li> <li>Frequent Updates &amp; Maintenance\u00a0\u2013 Regular updates, tuning, and maintenance are necessary for smooth operation.</li> <li>Security Risks\u00a0\u2013 While DBMS provides security measures, improper configuration can make data vulnerable to attacks.</li> <li>Hardware &amp; Storage Requirements\u00a0\u2013 Large-scale databases require significant storage and powerful hardware.</li> </ol>"},{"location":"unit1/#history-of-database-system","title":"History of Database System","text":"<p>A\u00a0Database Management System (DBMS)\u00a0is software that allows users to create, store, manage, and retrieve data efficiently. The evolution of DBMS dates back to the early days of computing and has undergone significant advancements over the decades</p> <p>1. Early DBMS (1960s - 1970s)</p> <ul> <li>The first DBMSs were developed in the\u00a01960s\u00a0for\u00a0scientific and military applications, primarily designed for use on\u00a0mainframe computers.</li> <li>Integrated Data Store (IDS), developed by\u00a0General Electric, was one of the first DBMSs to introduce a\u00a0high-level Data Definition Language (DDL)\u00a0and\u00a0Data Manipulation Language (DML).</li> <li>The\u00a0Hierarchical Model\u00a0(e.g., IBM's\u00a0IMS) and the\u00a0Network Model\u00a0(e.g.,\u00a0CODASYL) structured data in tree-like and graph-like forms, respectively.</li> <li>Limitations:\u00a0Rigid structures, complex relationships, and difficult maintenance.</li> </ul> <p>2. Relational DBMS Revolution (1970s - 1980s)</p> <ul> <li>In\u00a01970,\u00a0Dr. Edgar F. Codd\u00a0introduced the\u00a0Relational Model, where data was stored in\u00a0tables (relations)\u00a0with\u00a0rows (tuples)\u00a0and\u00a0columns (attributes).</li> <li>The relational model introduced\u00a0normalization, reducing redundancy and improving data integrity.</li> <li>IBM\u2019s\u00a0System R\u00a0(mid-1970s) was the first\u00a0commercial relational DBMS.</li> <li>Other popular\u00a0RDBMS:<ul> <li>Oracle (1979), IBM Db2 (1983), Microsoft SQL Server (1989), MySQL (1995)</li> </ul> </li> </ul> <p>Advantages:</p> <p>\u2714 Easy data retrieval using\u00a0SQL (Structured Query Language).</p> <p>\u2714 Reduced redundancy and improved consistency.</p> <p>3. Object-Oriented &amp; Web-Based Databases (1980s - 1990s)</p> <ul> <li>Object-Oriented DBMS (OODBMS)\u00a0emerged to address relational DBMS limitations.</li> <li>Data was stored in the form of\u00a0objects, integrating with Object-Oriented Programming.</li> <li>In the\u00a01990s,\u00a0web-based DBMS\u00a0allowed data access via\u00a0web browsers, enabling\u00a0remote and cross-platform sharing.</li> </ul> <p>4. NoSQL &amp; Big Data (2000s - Present)</p> <ul> <li>NoSQL Databases\u00a0were introduced in the\u00a0early 2000s\u00a0to handle\u00a0large-scale, unstructured data\u00a0in distributed computing environments.</li> <li>Types of\u00a0NoSQL Databases:<ul> <li>Key-Value Stores (e.g., Redis, DynamoDB)</li> <li>Document Stores (e.g., MongoDB, CouchDB)</li> <li>Column Stores (e.g., Cassandra, HBase)</li> <li>Graph Databases (e.g., Neo4j)</li> </ul> </li> </ul> <p>Advantages:</p> <p>\u2714 Highly scalable and flexible for modern applications.</p> <p>5. Cloud &amp; Distributed Databases (2010s - Present)</p> <ul> <li>Cloud Databases\u00a0(e.g., Google Cloud Spanner, Amazon Aurora) emerged to support scalable, real-time applications.</li> <li>Distributed Databases\u00a0ensure high availability across multiple locations.</li> <li>New trends:<ul> <li>NewSQL\u00a0(e.g., CockroachDB) combines relational features with NoSQL scalability.</li> <li>AI-driven Databases\u00a0for\u00a0self-optimization\u00a0and\u00a0automation.</li> <li>Blockchain Databases\u00a0for secure, decentralized storage.</li> </ul> </li> </ul>"},{"location":"unit1/#file-system-approcah","title":"File System Approcah","text":"<p>The\u00a0File System Approach\u00a0is a traditional method of storing and managing data in files on a storage device without a centralized database management system (DBMS). It relies on operating system file-handling mechanisms to store, retrieve, and manipulate data</p> <p>Characteristics</p> <ol> <li>Data is Stored in Files\u00a0\u2013 Each application has its own set of files, and data is stored in separate text or binary files.</li> <li>Manual Data Management\u00a0\u2013 Users and applications must manually handle data access, retrieval, and updates.</li> <li>Limited Data Sharing\u00a0\u2013 Data is difficult to share between applications due to lack of standardization.</li> <li>No Centralized Control\u00a0\u2013 Each file is managed separately without a common structure.</li> <li>Data Redundancy &amp; Inconsistency\u00a0\u2013 The same data may be duplicated in multiple files, leading to inconsistencies</li> </ol> <p>Disadvantages</p> <ol> <li>Data Redundancy\u00a0\u2013 Duplicate data in multiple files wastes storage space.</li> <li>Data Inconsistency\u00a0\u2013 Changes in one file may not be reflected in others, leading to mismatches.</li> <li>Lack of Security\u00a0\u2013 No built-in authentication or access control mechanisms.</li> <li>Difficult Data Retrieval\u00a0\u2013 Searching for specific data requires manual or programmatic effort.</li> <li>Concurrency Issues\u00a0\u2013 Multiple users accessing the same file can cause conflicts and data corruption.</li> <li>No ACID Properties\u00a0\u2013 Transactions are not managed properly, leading to data integrity issues.</li> <li>Difficult Backup &amp; Recovery\u00a0\u2013 Manual backups are required, and recovering lost data is complex.</li> </ol> <p>Advantages</p> <ol> <li>Simple &amp; Easy to Use\u00a0\u2013 Requires no complex setup; files can be created and managed easily.</li> <li>Low Cost\u00a0\u2013 No need for expensive database software; works with basic operating system tools.</li> <li>Faster for Small-Scale Applications\u00a0\u2013 Works well for small tasks where a full\u00a0DBMS\u00a0is unnecessary.</li> <li>No Overhead\u00a0\u2013 No extra processing for security, transaction management, or query optimization.</li> <li>Efficient for Specific Tasks\u00a0\u2013 Useful for storing logs, configuration files, or temporary data.</li> <li>Less Hardware Requirement\u00a0\u2013 Does not require high-end hardware or large storage capacity.</li> <li>Customizable\u00a0\u2013 Developers can structure and manage files according to specific application needs.</li> </ol> <p>Difference between FSA and DBMS</p> Feature FSA DBMS Data Storage Data is stored in separate files manually. Data is stored in a structured format using tables. Data Redundancy High redundancy due to duplicate data in multiple files. Minimizes redundancy through\u00a0Normalization. Data Consistency Low consistency as changes in one file may not reflect in others. Ensures consistency with constraints and\u00a0ACID properties. Data Integrity No built-in integrity constraints. Uses\u00a0primary keys, foreign keys, and constraints for data accuracy. Security No authentication or access control. Provides\u00a0user authentication, permissions, and encryption. Data Sharing Difficult to share data across applications. Multiple users and applications can easily share data. Concurrency Control No mechanism to handle multiple users accessing the same file. Uses\u00a0locking, transactions, and\u00a0ACID properties\u00a0for safe concurrent access. Data Retrieval Requires manual searching or custom programming. Supports\u00a0SQL\u00a0for fast and efficient data retrieval. Backup &amp; Recovery Manual backup; data recovery is complex. Automated\u00a0backup and recovery\u00a0mechanisms available. Scalability Limited scalability; performance degrades with data growth. Highly scalable; efficiently handles large amounts of data. Cost Low initial cost; does not require additional software. High setup cost due to software, hardware, and management. Complexity Simple and easy to use. More complex but provides advanced features."},{"location":"unit1/#view-of-data","title":"View of Data","text":"<p>Schema:\u00a0The overall design of the database is called schema</p> <p>For example - In a program we do variable declaration and assignment of values to the variable. The variable declaration is called schema and the value assigned to the variable is called instance. The schema for the student record can be</p> Roll No Name Marks <p>Instances:\u00a0When information is inserted or deleted from the database then the database gets changed. The collection of information at particular moment is called instances. For example - following is an instance of student database</p> Roll No Name Marks 10 AAA 43 20 BBB 67 <p>Types of Schema:\u00a0The database has several schema based on the levels of abstraction.</p> <p>(1) Physical Schema:\u00a0The physical schema is a database design described at the physical level of abstraction.</p> <p>(2) Logical Schema:\u00a0The logical schema is a database design at the logical level of abstraction.</p> <p>(3) Subschema:A database may have several views at the view level which are called\u00a0subschemas.</p>"},{"location":"unit1/#data-abstraction","title":"Data Abstraction","text":"<p>Data abstraction in DBMS refers to the process of hiding unnecessary details from end users while providing only the relevant data. Database systems involve complex data structures and relationships, but data abstraction ensures that users interact with data without needing to understand these complexities.</p> <p>Levels of Data Abstraction</p> <p></p> <ol> <li>Physical Level (Internal Level)<ul> <li>Lowest level of abstraction.</li> <li>Defines how data is stored using data structures, indexing, and access methods.</li> <li>Concerned with database performance, optimization, and storage mechanisms.</li> <li>Example:<ul> <li>A customer\u2019s information is stored in tables, but at the physical level, it is managed as data blocks.</li> <li>Indexed file organization allows record retrieval using indexes, while sequential file organization stores records in a continuous manner.</li> </ul> </li> </ul> </li> <li>Logical Level (Conceptual Level)<ul> <li>Middle level of abstraction.</li> <li>Defines what data is stored and the relationships between them.</li> <li>Represents entities, attributes, and relationships among tables.</li> <li>Less complex than the physical level but still requires knowledge of the database schema.</li> <li>Example:<ul> <li>A table\u00a0\"Students\"\u00a0with attributes\u00a0student_name, roll_no, student_ID, and marks.</li> <li>A table\u00a0\"Teachers\"\u00a0containing teacher_ID, address, and linked student_IDs (foreign key).</li> </ul> </li> </ul> </li> <li>View Level (External Level)<ul> <li>Highest level of abstraction.</li> <li>Provides different views of the database for different users, showing only relevant data.</li> <li>Facilitates interaction with the database using Graphical User Interfaces (GUIs).</li> <li>Example:<ul> <li>A teacher\u2019s view of a student database may show\u00a0student names and marks, while an admin may access\u00a0fees and attendance records.</li> </ul> </li> </ul> </li> </ol> <p>Features of Data Abstraction</p> <ol> <li> <p>Multiple Levels of Abstraction: DBMS provides three levels of abstraction:</p> <ul> <li>External Level (View Level):\u00a0Users see only the relevant part of the database without needing to know its internal structure.</li> <li>Conceptual Level (Logical Level):\u00a0Defines the structure and relationships of data without focusing on physical storage.</li> <li>Internal Level (Physical Level):\u00a0Deals with the actual storage of data in memory and databases.</li> </ul> </li> </ol> <p>2. Separation of Concerns</p> <ul> <li>Different users (end users, database designers, and administrators) can interact with the database at different abstraction levels.</li> <li>Ensures that logical design and physical storage are independent, simplifying database management.</li> </ul> <p>3. Mapping Between Levels</p> <ul> <li>Provides a structured way to link different abstraction levels, ensuring changes at one level do not affect others.</li> <li>Example: A change in storage structure at the physical level does not affect the conceptual or external levels.</li> </ul> <p>4. Data Independence</p> <ul> <li>Logical Data Independence:\u00a0Changes in the logical structure do not impact external views.</li> <li>Physical Data Independence:\u00a0Changes in storage methods do not affect logical schema.</li> </ul> <p>5. Transparency</p> <ul> <li>Hides complex implementation details, providing a simplified and consistent view of data to users.</li> <li>Users can retrieve and manipulate data without knowing its actual storage or retrieval mechanisms.</li> </ul> <p>6. Security and Controlled Access</p> <ul> <li>Restricts access to sensitive data by defining different views for different users.</li> <li>Ensures that unauthorized users cannot see or modify restricted information.</li> </ul> <p>7. Enhanced Maintainability &amp; Flexibility</p> <ul> <li>Simplifies updates, modifications, and scaling of the database.</li> <li>Reduces the impact of structural changes on users and applications.</li> </ul> <p>Advantages of Data Abstraction</p> <ol> <li> <p>Simplifies User Interaction: Users do not  need to understand storage complexities.</p> </li> <li> <p>Improves Security: Sensitive data is hidden, ensuring restricted access.</p> </li> <li> <p>Reduces Complexity: Users work with simplified views, while DBMS handles complex operations.</p> </li> <li> <p>Increases Flexibility: Structural changes in the database do not affect user experience.</p> </li> <li> <p>Enhances Data Integrity: Ensures consistent and correct data storage.</p> </li> </ol>"},{"location":"unit1/#data-independance","title":"Data Independance","text":"<p>Data Independence\u00a0refers to the ability to modify a database schema at one level without affecting the schema at the next higher level. It ensures that changes in storage, structure, or organization do not impact the way users interact with data. This is one of the key characteristics of a\u00a0(DBMS)\u00a0as it helps in managing large amounts of data efficiently and ensures adaptability over time.</p> <p>Importance of Data Independence:</p> <ul> <li>A database contains vast amounts of data that must be frequently updated to meet changing requirements.</li> <li>A\u00a0multi-layer architecture\u00a0is used in DBMS to ensure that modifications at one level do not affect other levels.</li> <li>The\u00a0three levels of abstraction\u2014Physical Level, Logical Level, and View Level\u2014help achieve data independence.</li> <li>Data independence improves maintainability, flexibility, security, and cost-effectiveness in database management.</li> </ul> <p>Physical Data Independence</p> <p>Physical data independence is the ability to modify the\u00a0physical schema\u00a0(how and where data is stored) without affecting the\u00a0logical schema\u00a0(conceptual structure) or the\u00a0view level\u00a0(user interactions).</p> <p>Key Aspects:</p> <ul> <li>Changes in storage structure, indexing methods, or hardware do not require changes in the database schema or applications.</li> <li>Helps in optimizing storage and improving performance without impacting user accessibility.</li> </ul> <p>Examples:</p> <ol> <li>Changing from one data structure to another (e.g., switching from B-trees to hash indexes).</li> <li>Using a new storage technology, such as moving from HDDs to SSDs or cloud storage.</li> <li>Changing the location of database files from one drive to another.</li> <li>Modifying the database file organization (e.g., partitioning tables for faster queries).</li> </ol> <p>Logical Data Independence</p> <p>Logical data independence is the ability to modify the\u00a0logical schema\u00a0(organization, structure, or relationships of data) without affecting the\u00a0external schema\u00a0(user views and application programs).</p> <p>Key Aspects:</p> <ul> <li>Ensures that applications remain unaffected by changes in data structure.</li> <li>Compared to physical data independence,\u00a0logical data independence is harder to achieve\u00a0because changes in relationships or attributes might require modifications in queries and reports.</li> </ul> <p>Examples:</p> <ol> <li>Adding, modifying, or deleting an attribute, entity, or relationship without rewriting existing application programs.</li> <li>Merging two tables into one or splitting an existing table into multiple tables.</li> <li>Changing constraints or data types of existing attributes without affecting user interactions</li> </ol> <p>Differences between PDI &amp; LDI</p> Feature PDI LDI Definition Changes in physical storage do not affect logical structure. Changes in logical structure do not affect user views or applications. Affects Storage structures, file organization, indexing. Database schema, tables, attributes, relationships. Ease of Implementation Easier to achieve. Harder to achieve. Ease of Retrieving we can retrieve it easily retrieving is very difficult because the data mainly depends on its logical structure not its physical location Types of Schema the internal schema is the primary concern the conceptual schema is the primary concern Examples Changing storage devices, file locations. Adding new attributes, splitting tables."},{"location":"unit1/#ef-codd-rules","title":"EF Codd Rules","text":"<p>Dr.\u00a0Edgar F. Codd, a computer scientist, proposed a set of\u00a012 rules\u00a0(plus Rule 0) to define what qualifies as a\u00a0Relational Database Management System (RDBMS). These rules ensure\u00a0data integrity, consistency, usability, and independence\u00a0in database management</p> <ul> <li> <p>Rule 0: The Foundation Rule</p> <p>A database must be structured in a\u00a0relational manner, and its management should be entirely based on\u00a0relational capabilities\u00a0to be considered an RDBMS.</p> </li> <li> <p>Rule 1: The Information Rule</p> <ul> <li>All\u00a0data and metadata\u00a0(information about the database) must be stored in tables as values within cells.</li> <li>The entire database should follow a\u00a0tabular format\u00a0to maintain consistency.</li> </ul> </li> <li>Rule 2: The Guaranteed Access Rule<ul> <li>Each data item must be accessible using a\u00a0combination of table name, primary key (row identifier), and attribute name (column identifier).</li> <li>This ensures that no data is left inaccessible.</li> </ul> </li> <li>Rule 3: Systematic Treatment of NULL Values<ul> <li>NULL values\u00a0(representing missing or unknown data) should be handled uniformly across the system.</li> <li>NULL should be\u00a0distinct\u00a0from blank spaces or zero values.</li> </ul> </li> <li>Rule 4: Active Online Catalog Rule<ul> <li>Metadata (information about database structure) should be\u00a0stored within the database itself\u00a0as tables.</li> <li>Users should be able to query this catalog using the same language (e.g., SQL) used for regular data queries.</li> </ul> </li> <li> <p>Rule 5: The Comprehensive Data Sublanguage Rule</p> <p>The database should support a single, well-defined language (such as SQL) for:</p> <ul> <li>Data Definition (DDL)\u00a0\u2013 Creating and modifying tables.</li> <li>Data Manipulation (DML)\u00a0\u2013 Querying, inserting, updating, and deleting records.</li> <li>Access Control\u00a0\u2013 Managing security and authorization.</li> </ul> </li> <li> <p>Rule 6: The View Updating Rule</p> <ul> <li>A\u00a0view\u00a0(a virtual table based on query results) should be updatable if it is\u00a0theoretically possible\u00a0to do so.</li> <li>This ensures\u00a0data consistency\u00a0when using views.</li> </ul> </li> <li>Rule 7: High-level Insert, Update, and Delete<ul> <li>The system should allow\u00a0set-level operations, meaning users can\u00a0insert, update, or delete multiple rows\u00a0at once using a single query.</li> <li>This improves\u00a0efficiency and usability.</li> </ul> </li> <li>Rule 8: Physical Data Independence<ul> <li>Changes in\u00a0physical storage structures\u00a0(e.g., moving data to different disks)\u00a0should not affect applications\u00a0that access the database.</li> <li>This ensures\u00a0hardware flexibility\u00a0without disrupting the system.</li> </ul> </li> <li>Rule 9: Logical Data Independence<ul> <li>Changes in the\u00a0logical schema\u00a0(e.g., adding/modifying tables or columns)\u00a0should not require changes in application programs.</li> <li>This makes the system more\u00a0adaptable\u00a0to future modifications.</li> </ul> </li> <li>Rule 10: Integrity Independence<ul> <li>Integrity constraints\u00a0(such as\u00a0primary keys, foreign keys, and unique constraints) must be\u00a0defined separately from applications\u00a0and stored within the database catalog.</li> <li>These constraints should be\u00a0enforced automatically\u00a0by the system.</li> </ul> </li> <li>Rule 11: Distribution Independence<ul> <li>Whether the database is\u00a0centralized or distributed across multiple locations, it should behave the\u00a0same way\u00a0for users.</li> <li>Distribution should be\u00a0transparent, meaning users don\u2019t need to know where the data is physically stored.</li> </ul> </li> <li>Rule 12: Non-Subversion Rule<ul> <li>The system should prevent users from\u00a0bypassing security and integrity constraints\u00a0through low-level access methods (e.g., file handling).</li> <li>Even if a system provides direct access to records,\u00a0security measures must not be compromised.</li> </ul> </li> </ul>"},{"location":"unit1/#db-languages","title":"DB: Languages","text":"<p>Database languages are used to create, manipulate, retrieve, and manage data in a\u00a0Database Management System (DBMS). The main types of database languages are:</p> <p>1. Data Definition Language (DDL)</p> <ul> <li>Used to\u00a0define and modify\u00a0the database structure.</li> <li> <p>Includes commands for\u00a0creating, altering, and deleting\u00a0tables and schemas.</p> Command Description <code>CREATE</code> Creates a new database, table, or view <code>ALTER</code> Modifies an existing database structure <code>DROP</code> Deletes a database, table, or column <code>TRUNCATE</code> Removes all records from a table without deleting its structure <pre><code>CREATE TABLE Employees (\n    EmployeeID INT PRIMARY KEY,\n    Name VARCHAR(50),\n    Age INT,\n    Department VARCHAR(50)\n);\n\nALTER TABLE Employees ADD Salary DECIMAL(10,2);\n\nDROP TABLE Employees;\n\nTRUNCATE TABLE Employees;\n</code></pre> </li> </ul> <p>2. Data Manipulation Language (DML)</p> <ul> <li>Used to\u00a0retrieve and manipulate\u00a0data stored in the database.</li> <li>Allows\u00a0insertion, deletion, modification, and retrieval\u00a0of data.</li> </ul> Command Description <code>SELECT</code> Retrieves data from a database <code>INSERT</code> Adds new data to a table <code>UPDATE</code> Modifies existing records in a table <code>DELETE</code> Removes records from a table <p>Types of DML:</p> <ul> <li>Procedural DML\u00a0\u2013 Requires the user to specify\u00a0how\u00a0to retrieve data.</li> <li> <p>Non-Procedural DML\u00a0\u2013 Requires the user to specify\u00a0what\u00a0data to retrieve, letting the system handle retrieval (e.g., SQL).</p> <pre><code>SELECT Name, Age FROM Employees WHERE Department = 'HR';\n\nINSERT INTO Employees (EmployeeID, Name, Age, Department, Salary) \nVALUES (101, 'Alice', 30, 'IT', 50000.00);\n\nUPDATE Employees SET Salary = 55000.00 WHERE EmployeeID = 101;\n</code></pre> </li> </ul> <p>3. Data Control Language (DCL)</p> <ul> <li>Used to\u00a0control user access\u00a0to the database.</li> <li> <p>Ensures\u00a0security and authorization\u00a0for database operations.</p> Command Description <code>GRANT</code> Gives users permissions to perform database operations <code>REVOKE</code> Removes permissions from a user <pre><code>GRANT SELECT, INSERT ON Employees TO user1;\n\nREVOKE INSERT ON Employees FROM user1;\n</code></pre> </li> </ul> <p>4. Transaction Control Language (TCL)</p> <ul> <li>Used to\u00a0manage transactions\u00a0in a database to ensure\u00a0consistency and integrity.</li> <li> <p>Helps in\u00a0rollback, commit, and savepoint\u00a0operations.</p> Command Description <code>COMMIT</code> Saves all changes made by the transaction permanently <code>ROLLBACK</code> Reverts all changes made in the current transaction <code>SAVEPOINT</code> Creates a checkpoint in a transaction, allowing partial rollbacks <pre><code>BEGIN TRANSACTION;\nUPDATE Employees SET Salary = 60000 WHERE EmployeeID = 101;\nCOMMIT;\n\nBEGIN TRANSACTION;\nUPDATE Employees SET Salary = 65000 WHERE EmployeeID = 101;\nROLLBACK;\n\nBEGIN TRANSACTION;\nUPDATE Employees SET Salary = 60000 WHERE EmployeeID = 101;\nSAVEPOINT BeforeRaise;\nUPDATE Employees SET Salary = 65000 WHERE EmployeeID = 101;\nROLLBACK TO BeforeRaise;\n</code></pre> </li> </ul>"},{"location":"unit1/#db-design-process","title":"DB: Design Process","text":"<ul> <li>The\u00a0database design process\u00a0is a structured approach to developing a\u00a0Database Management System (DBMS)\u00a0that ensures\u00a0efficient data storage, retrieval, integrity, and security.</li> <li>A well-designed database meets user requirements while maintaining\u00a0scalability, performance, and reliability.</li> <li>The database design process consists of several\u00a0phases, each playing a crucial role in ensuring the success of the database application.By following these phases:</li> <li>Requirement Collection &amp; Analysis\u00a0\u2013 Gather user needs.</li> <li>Conceptual Design\u00a0\u2013 Create ER models.</li> <li>Logical Design\u00a0\u2013 Convert to relational schema.</li> <li>Physical Design\u00a0\u2013 Optimize storage and indexing.</li> <li>Implementation &amp; Data Loading\u00a0\u2013 Create and populate the database.</li> <li>Testing &amp; Evaluation\u00a0\u2013 Ensure functionality and performance.</li> <li>Maintenance &amp; Optimization\u00a0\u2013 Continuously monitor and improve.</li> </ul> <p>1. Requirement Collection and Analysis Phase</p> <p>This phase involves gathering detailed\u00a0user and functional requirements\u00a0for the database.</p> <p>Key Activities:</p> <ul> <li>Conduct\u00a0interviews\u00a0and\u00a0meetings\u00a0with prospective users to understand their needs.</li> <li>Identify\u00a0data flow, user operations, transaction frequency, and security requirements.</li> <li>Document requirements using\u00a0diagrams\u00a0such as:<ul> <li>Sequence Diagrams\u00a0(User interactions)</li> <li>Data Flow Diagrams (DFDs)\u00a0(Data movement)</li> <li>Use Case Scenarios\u00a0(Real-world use cases)</li> </ul> </li> </ul> <p>Outcome:</p> <ul> <li>A\u00a0comprehensive requirements document\u00a0that serves as the foundation for database design.</li> <li>Defines the\u00a0functional scope\u00a0of the database.</li> <li>This phase plays a\u00a0vital role\u00a0in the success of the database and ensures that\u00a0all stakeholder needs\u00a0are accounted for.</li> </ul> <p>2. Conceptual Design Phase</p> <p>In this phase, a\u00a0conceptual schema\u00a0is developed to represent the\u00a0overall structure of the database\u00a0without focusing on technical implementation details.</p> <p>Key Activities:</p> <ul> <li>Select an appropriate\u00a0data model\u00a0(e.g.,\u00a0Entity-Relationship (ER) Model).</li> <li>Identify\u00a0entities, attributes, relationships, and constraints.</li> <li>Represent the data using an\u00a0ER diagram.</li> </ul> <p>Outcome:</p> <ul> <li>A\u00a0high-level conceptual schema\u00a0that ensures all user requirements are met without conflicts.</li> <li>The design remains\u00a0independent of any specific RDBMS\u00a0(e.g., MySQL, PostgreSQL).</li> <li>Acts as a\u00a0communication tool\u00a0between designers and end users.</li> </ul> <p>3. Logical Design Phase</p> <p>This phase translates the\u00a0conceptual schema\u00a0into a\u00a0relational schema\u00a0that can be implemented in an RDBMS.</p> <p>Key Activities:</p> <ul> <li>Convert\u00a0ER diagrams\u00a0into\u00a0tables, attributes, primary keys (PK), and foreign keys (FK).</li> <li>Define\u00a0constraints\u00a0(e.g.,\u00a0<code>NOT NULL</code>,\u00a0<code>UNIQUE</code>,\u00a0<code>CHECK</code>) to ensure data integrity.</li> <li>Normalize data to remove redundancy and improve consistency.</li> </ul> <p>Outcome:</p> <ul> <li>A\u00a0relational schema\u00a0that is\u00a0structured and optimized\u00a0for efficient data operations.</li> <li>Provides a\u00a0detailed framework\u00a0for physical database implementation.</li> </ul> <p>Example:</p> Student Table Course Table Enrollment Table Student_ID (PK) Course_ID (PK) Student_ID (FK) Name Course_Name Course_ID (FK) Age <p>4. Physical Design Phase</p> <p>In this phase, technical\u00a0decisions about storage and performance optimization\u00a0are made.</p> <p>Key Activities:</p> <ul> <li>Define\u00a0storage structures, indexing, partitioning, and file organization.</li> <li>Optimize for\u00a0performance, scalability, and security.</li> <li>Choose\u00a0appropriate database servers and application environments.</li> </ul> <p>Outcome:</p> <ul> <li>A\u00a0physical design specification\u00a0that includes:<ul> <li>Database\u00a0storage architecture.</li> <li>Indexing strategies to\u00a0improve query performance.</li> <li>Security configurations and\u00a0access control policies.</li> </ul> </li> </ul> <p>5. Implementation and Data Loading Phase</p> <p>This phase involves the\u00a0creation of the database\u00a0and\u00a0loading of data.</p> <p>Key Activities:</p> <ul> <li>Implement the database using\u00a0SQL DDL (Data Definition Language) commands.</li> <li>Populate tables manually or automatically by\u00a0migrating data from an existing system.</li> <li>Configure\u00a0database security and user roles.</li> </ul> <p>Outcome:</p> <ul> <li>A\u00a0fully operational database\u00a0with initial data loaded.</li> <li>Ready for\u00a0testing and validation.</li> </ul> <p>Example:</p> <pre><code>sql\nCopyEdit\nCREATE TABLE Student (\n    Student_ID INT PRIMARY KEY,\n    Name VARCHAR(50),\n    Age INT\n);\n\nINSERT INTO Student VALUES (1, 'Alice', 20);\n</code></pre> <p>6. Testing and Evaluation Phase</p> <p>This phase ensures that the database performs correctly and meets\u00a0functional and non-functional requirements.</p> <p>Key Activities:</p> <ul> <li>Test\u00a0data integrity, concurrency, security, and performance.</li> <li>Optimize database queries for\u00a0efficiency.</li> <li>Identify issues and apply\u00a0modifications if needed\u00a0(e.g., improving indexing, adjusting constraints).</li> </ul> <p>Outcome:</p> <ul> <li>A\u00a0fully optimized\u00a0and\u00a0functional\u00a0database system.</li> <li>Any performance issues or security risks are addressed before deployment.</li> </ul> <p>Example:</p> <ul> <li>Testing whether a user can register for a\u00a0non-existent course:</li> </ul> <pre><code>SELECT * FROM Enrollment WHERE Course_ID NOT IN (SELECT Course_ID FROM Course);\n</code></pre> <p>7. Maintenance and Optimization Phase</p> <p>This phase ensures the database remains\u00a0efficient, secure, and up to date\u00a0over time.</p> <p>Key Activities:</p> <ul> <li>Regular\u00a0monitoring and performance tuning.</li> <li>Implement\u00a0backup and recovery plans\u00a0to prevent data loss.</li> <li>Modify the schema if\u00a0business requirements change.</li> </ul> <p>Outcome:</p> <ul> <li>A\u00a0reliable and well-maintained database\u00a0that continues to perform efficiently.</li> <li>Security vulnerabilities and performance bottlenecks are periodically addressed.</li> </ul>"},{"location":"unit1/#db-architecture","title":"DB: Architecture","text":"<ul> <li>The DBMS design depends upon its architecture. The basic client/server architecture is used to deal with a large number of PCs, web servers, database servers and other components that are connected with networks.</li> <li>The client/server architecture consists of many PCs and a workstation which are connected via the network.</li> <li>DBMS architecture depends upon how users are connected to the database to get their request done.</li> </ul> <p>1 Tier</p> <p>In\u00a01-Tier Architecture, the database, client, and server are all located on the same machine. This architecture allows the user to directly interact with the database, making it suitable for personal or standalone applications.</p> <p></p> <ul> <li>Example: Microsoft Excel\u00a0is a one-tier system where data is stored and processed on the same computer.</li> </ul> <p>Features</p> <ul> <li>All-in-One System: The user interface (UI), application logic, and data are all managed on the same machine.</li> <li>No External Network or Server Connection: Everything is self-contained, requiring no external connections.</li> </ul> <p>Advantages</p> <p>\u2714\u00a0Simple Setup\u00a0\u2013 Only one machine is needed.</p> <p>\u2714\u00a0Cost-Effective\u00a0\u2013 No need for additional hardware or network infrastructure.</p> <p>\u2714\u00a0Easy Deployment\u00a0\u2013 Ideal for small projects with minimal setup requirements</p> <p>2 Tier</p> <p>The 2-Tier Architecture follows a client-server model, where the client directly communicates with the database server using APIs like ODBC/JDBC. The server handles query processing and transaction management, while the client runs the user interface and application logic.</p> <p></p> <ul> <li> <p>Example: Library Management System</p> <ol> <li> <p>Client Layer (Tier 1) \u2013 A desktop application used to search books, issue them, and check due dates.</p> </li> <li> <p>Database Layer (Tier 2) \u2013 Stores all book records, user information, and transaction logs.</p> </li> </ol> <p>When a user searches for a book, the client sends a request to the database, which processes the query and returns the result.</p> </li> </ul> <p>Advantages</p> <p>\u2714 Faster Access \u2013 Direct communication speeds up query execution.</p> <p>\u2714 Scalability \u2013 Easy to add clients or upgrade hardware.</p> <p>\u2714 Low Cost \u2013 More affordable than 3-tier and multi-tier architectures.</p> <p>\u2714 Easy Deployment \u2013 Simple to set up compared to 3-tier systems.</p> <p>3 Tier</p> <p>In 3-Tier Architecture, an additional application server sits between the client and database, acting as an intermediary. The client does not directly communicate with the database, improving security and scalability.</p> <p></p> <p>Example: E-Commerce Store</p> <ol> <li> <p>Client (User) \u2013 Searches for a product and adds it to the cart.</p> </li> <li> <p>Application Server (Processing) \u2013 Checks product availability, applies discounts, and calculates the total price.</p> </li> <li> <p>Database Server \u2013 Stores product details, order history, and user information.</p> </li> </ol> <p>Advantages</p> <p>\u2714 Enhanced Scalability \u2013 Distributes workload, reducing direct database connections.</p> <p>\u2714 Data Integrity \u2013 The middle layer prevents data corruption and enhances consistency.</p> <p>\u2714 Improved Security \u2013 Restricts direct access to the database, reducing unauthorized data access.</p> <p>Disadvantages</p> <p>\u2716 Increased Complexity \u2013 More components mean higher setup and maintenance costs.</p> <p>\u2716 Slower Interaction \u2013 Additional layers increase processing time.</p>"},{"location":"unit1/#dbs-architecture","title":"DBS: Architecture","text":""},{"location":"unit1/#1-system-users","title":"1. System Users","text":"<p>A database system has four primary types of users:</p> <p>1. Naive Users</p> <ul> <li>Unsophisticated users who interact with the system through pre-written application programs.</li> <li>Example: A ticket booking clerk using a reservation system.</li> </ul> <p>2. Application Developers</p> <ul> <li>Responsible for creating software applications that interact with the database.</li> <li>Develop APIs to facilitate communication between applications and the database.</li> </ul> <p>3. Sophisticated Users</p> <ul> <li>Interact with the database without writing programs.</li> <li>Use database query languages to form requests.</li> <li>Their queries are processed by the query processor, which translates high-level DML statements into instructions understood by the storage manager.</li> </ul> <p>4. Database Administrator (DBA)</p> <ul> <li>The DBA is responsible for managing and maintaining the database system.Key Role of DMA<ol> <li>Database Installation &amp; Configuration</li> <li>Set up database software, parameters, file structures, and security settings.</li> <li>Backup &amp; Recovery</li> <li>Ensure regular backups and implement a disaster recovery plan.</li> <li>Security Management</li> <li>Set up user accounts, define access permissions, and encrypt sensitive data.</li> <li>Performance Tuning</li> <li>Optimize database schema, tune queries, and manage system resources (memory, CPU, storage).</li> <li>Maintenance &amp; Upgrades</li> <li>Perform tasks like index optimization, defragmentation, and database migrations.</li> </ol> </li> </ul> <p>The functional components of a DBMS can be broadly divided into:</p> <ol> <li> <p>Query Processor</p> </li> <li> <p>Storage Manager</p> </li> </ol>"},{"location":"unit1/#1query-processor","title":"1.Query Processor","text":"<ul> <li>The query processor is responsible for interpreting and executing user queries.</li> <li>It transforms high-level queries (SQL) into low-level operations that the database engine can execute.</li> </ul> <p>Functions of the Query Processor</p> <ul> <li>Simplifies data access for users.</li> <li>Users do not need to understand the system\u2019s physical implementation.</li> <li>Ensures quick query processing and updates.</li> </ul> <p>Query Processor Components</p> <p>1. DDL Interpreter</p> <ul> <li>Processes Data Definition Language (DDL) statements.</li> <li>Handles commands for creating, modifying, and deleting database structures (tables, indexes, views, constraints).</li> </ul> <p>2. DML Compiler &amp; Organizer</p> <ul> <li>Processes Data Manipulation Language (DML) statements such as INSERT, UPDATE, DELETE, and SELECT.</li> <li>Converts high-level DML queries into low-level database operations.</li> <li>DML Compiler: Translates DML queries into executable instructions.</li> <li>DML Organizer: Executes the compiled query plan.</li> </ul> <p>3. Application Program Object Code (APOC)</p> <ul> <li>Compiled version of an application program that interacts with the database.</li> <li>Converts source code into machine-readable form.</li> </ul> <p>4. Compiler &amp; Linker</p> <ul> <li>Application programmers write source code.</li> <li>The compiler and linker process this code, linking it to DML queries before execution.</li> </ul> <p>5. Query Evaluation Engine</p> <ul> <li>Executes user queries and retrieves the requested data.Key Functions:</li> <li>Query Parsing &amp; Validation: Ensures correct syntax.</li> <li>Query Optimization: Determines the most efficient way to execute a query.</li> <li>Query Plan Generation: Creates an execution plan based on optimization.</li> <li>Data Retrieval &amp; Manipulation: Interacts with the storage manager to fetch data efficiently.</li> <li>Concurrency Control &amp; Transaction Management: Ensures data consistency in a multi-user environment.</li> <li>Result Formatting &amp; Delivery: Formats query results for the user.</li> </ul>"},{"location":"unit1/#2-data-storage-manager","title":"2. Data Storage Manager","text":"<ul> <li>Data Storage Manager also known as \u201cDatabase Control System\u201d, is generally a program that provides an interface between the data/information stored and the queries received.</li> <li>It is responsible for storing, retrieving, and updating database records.</li> <li>It helps us to maintain the integrity and consistency of the database by applying the constraints.</li> <li>It is a highly flexible and scalable product that provides us with the capability of fully managed storage.</li> </ul> <p>Functions of the Storage Manager</p> <ul> <li>Converts DML statements into low-level file system commands.</li> <li>Handles large storage requirements (hundreds of gigabytes to terabytes).</li> <li>Moves data between disk storage and main memory as needed.</li> </ul> <p>Components of the Storage Manager</p> <p>1. Authorization &amp; Integrity Manager</p> <ul> <li>Enforces integrity constraints and verifies user access rights.</li> </ul> <p>2. Transaction Manager</p> <ul> <li>Ensures database consistency despite system failures.</li> <li>Handles concurrent transactions without conflicts.</li> </ul> <p>3. File Manager</p> <ul> <li>Allocates storage space and manages data structures on disk.</li> </ul> <p>4. Buffer Manager</p> <ul> <li>Fetches data from disk storage to main memory.</li> <li>Manages memory caching of frequently accessed data.</li> <li>Enabling the database to handle data sizes that are much larger than the size of the main memory.</li> </ul>"},{"location":"unit1/#3disk-storage-in-dbms","title":"3.Disk Storage in DBMS","text":"<p>The storage manager implements several data structures as part of the physical system implementation:</p> <p>1. Data Files</p> <ul> <li>Store actual database records.</li> </ul> <p>2. Data Dictionary</p> <ul> <li>Stores metadata about the database structure, including:</li> <li>Table names, attributes, data types, and constraints.</li> <li>Indexes, views, and authorized users.</li> <li>Storage methods and optimization details.</li> </ul> <p>3. Indices</p> <ul> <li>Provide fast access to data using pointers.</li> <li>Example: Hashing can be used for quicker lookups in some cases.</li> </ul> <p>4. Statistical Data</p> <ul> <li>Stores statistical metadata, such as record count and block distribution.</li> <li>Helps optimize query execution.</li> </ul>"}]}